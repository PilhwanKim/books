# 11장 입력 유효성 검사 및 테스트 구조화

지금까지는 한개의 `functional_tests.py`, `tests.py` 로 태스트를 작성했다.

이후로 새로운 기능을 만들면 테스트가 늘어날 텐데 한 파일에 너무 많은 테스트가 있어서 찾기 힘들어진다.

그래서 테스트 코드를 여러개의 파일로 쪼개는 시간을 가진다.

그리고 또한 Generic wait helper 도 작성한다.

## 유효성 검사 FT에서 시작 : 빈 아이템 방지(예제 : [11-01](./11-01))

처음 몇 명의 사용자가 사이트를 사용하기 시작하면서 실수로 빈 목록 항목을 제출하거나 목록에 동일한 항목 2 개를 입력하는 등 목록을 엉망으로 만드는 실수를 발견한다.

이걸 방지하는 FT를 구상해보자.

### [/functional_tests/tests.py](./11-01/superlists/functional_tests/tests.py)

```sh
def test_cannot_add_empty_list_items(self):
    # 에디스는 메인 페이지에 접속해서 빈 아이템을 실수로 등록하려고 한다.
    # 입력 상자가 비어있는 상태에서 엔터키를 누른다.

    # 페이지가 새로 고침되고, 빈 아이템을 등록할 수 없다는
    # 에러 메시지가 표시된다

    # 다른 아이템을 입력하고 이번에는 정상 처리된다

    # 그녀는 고의적으로 다시 빈 아이템을 등록한다.

    # 리스트 페이지에 다시 에러 메시지가 표시된다.

    # 아이템을 입력하면 정상 동작한다.
    self.fail('write me!')
```

테스트 파일이 복잡해지기 시작했기에 테스트 파일을 몇 개로 나누기 시작하자.

원칙 : 1 테스트 파일에 하나의 테스트만 넣기

### 테스트 건너 뛰기

리펙터링 시에는 테스트가 모두 통과된 상태에서 진행하는 것이 좋음.

방금 고의적으로 실패하는 테스트를 작성했는데 `unittest` 의 `skip` 데코레이터를 이용해서 잠시 이 테스트를 꺼 두자.

```py

from unittest import skip
[...]
    @skip
    def test_cannot_add_empty_list_items(self):
```

테스트 실행시 이 테스트는 무시하도록 만든다. 테스트 실행하면 테스트가 통과됨을 알수 있다.

```sh
$ python manage.py test functional_tests
[...]
Ran 3 tests in 19.832s

OK
Destroying test database for alias 'default'...
```

### 레드, 그린, 리팩터 의 리팩터를 잊지 말자

TDD 의 문제가 되는 이유중 하나 코드 구조가 나빠지는 경향이 있다. 이유는 전체 시스템에 신경 쓰기보단 오로지 테스트가 통과되는 것에 초점을 맞추기 때문

설계 측면에서 TDD는 만병 통치약이 아니다. 방법론이 코드가 테스트를 통과하도록 하는것에 주안점이 있는 것만은 아니다. 설계를 개선하기 위해 리팩터링에 시간을 투자해야 한다는 것을 의미한다.

리팩터링의 최적의 아이디어는 바로 떠오르진 않는다. 몇주 혹은 몇달 지난후에 아이디어가 떠오르기도 한다. 지금 일을 멈추고 예전 코드를 리팩터링 해야하는 것일까?

케이스 1) 이번장의 시작과 같은 상황이라면 신규 FT는 skip 처리하고 바로 리팩터링을 시작할 수 있다.

케이스 2) 아직 변경 코드가 많이 남아있고 신규 FT는 fail 상태라면 기존 동작상태가 보장되지 않는다. 이때 리팩터링은 위험하다. 따라서 작업목록에 기록해두고 동작상태가 모두 통과 될때까지 기다린후 리팩터링 한다.

(결론)동작상태가 모두 통과되는 상태(all green)에서 리팩터링을 시도해야 한다.
